<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Here I Come" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="这是我在知乎上对这个问题的回答，因为辣鸡知乎吃我排版，再加上打开Markdown编辑器时候本来就在博客文件夹里，所以干脆就搬过来了。 这个答案会很长，我会尽量把对背景知识的需求压缩到高中数学和物理的大纲之内，相应的，也会牺牲一些严谨性和正确性。所以在看完这篇科普之后，万万不可对其中用到的一些比喻进行想当然地扩展与推广，会出大事的（指变成民科）。 &#x2F;&#x2F;写完才发现尽管是一些很基础的线性代数但是还是不在">
<meta property="og:type" content="article">
<meta property="og:title" content="什么是量子计算机？">
<meta property="og:url" content="http://hereicome.tk/p/46387.html">
<meta property="og:site_name" content="Here I Come">
<meta property="og:description" content="这是我在知乎上对这个问题的回答，因为辣鸡知乎吃我排版，再加上打开Markdown编辑器时候本来就在博客文件夹里，所以干脆就搬过来了。 这个答案会很长，我会尽量把对背景知识的需求压缩到高中数学和物理的大纲之内，相应的，也会牺牲一些严谨性和正确性。所以在看完这篇科普之后，万万不可对其中用到的一些比喻进行想当然地扩展与推广，会出大事的（指变成民科）。 &#x2F;&#x2F;写完才发现尽管是一些很基础的线性代数但是还是不在">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-22T15:28:45.000Z">
<meta property="article:modified_time" content="2020-03-07T07:24:57.298Z">
<meta property="article:author" content="Anchor">
<meta property="article:tag" content="量子信息">
<meta property="article:tag" content="量子计算">
<meta property="article:tag" content="线性代数">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hereicome.tk/p/46387.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>什么是量子计算机？ | Here I Come</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Here I Come</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">如何的春风得意也是人故事</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-fw fa-comments"></i>留言板</a>

  </li>
        <li class="menu-item menu-item-keywords">

    <a href="/keywords/" rel="section"><i class="fa fa-fw fa-book"></i>单词化日记</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hereicome.tk/p/46387.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Anchor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Here I Come">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          什么是量子计算机？
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-22 23:28:45" itemprop="dateCreated datePublished" datetime="2020-02-22T23:28:45+08:00">2020-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">科学</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/p/46387.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/p/46387.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
              <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是我在知乎上对<a href="https://www.zhihu.com/question/373468198/answer/1032005529" target="_blank" rel="noopener">这个问题</a>的回答，因为辣鸡知乎吃我排版，再加上打开Markdown编辑器时候本来就在博客文件夹里，所以干脆就搬过来了。</p>
<p>这个答案会很长，我会尽量把对背景知识的需求压缩到高中数学和物理的大纲之内，相应的，也会牺牲一些严谨性和正确性。所以在看完这篇科普之后，万万不可对其中用到的一些比喻进行想当然地扩展与推广，会出大事的（指变成民科）。</p>
<p>//写完才发现尽管是一些很基础的线性代数但是还是不在高中数学范畴之中……emmmm没关系直接把结论记下来就好。</p>
<h2 id="比特与量子比特"><a class="markdownIt-Anchor" href="#比特与量子比特"></a> 比特与量子比特</h2>
<p>在经典计算机中，一个机器的「状态」的最小单位是比特（bit），可以是0/1，是VCC/GND，是带磁/消磁，总之是一种确定的，非此即彼的状态，是1就不能再是0，是VCC就不能是GND。</p>
<p>而在量子计算机中我们常听说，一个量子比特（Qubit）可以是1和0的叠加。常识与直觉会让我们以为这种叠加就是0.3, 0.5, 0.8 那样在数轴上从0和1中间选一个点。但事实上不是。在量子比特中，0和1不再是数轴上的两个点，他们实际上是两根<strong>互相垂直</strong>的数轴。为了避免混淆，我们引入新的符号<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\ket{0}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\ket{1}</annotation></semantics></math></span></eq>来描述它们。你可以把<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mo>⋅</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\ket{\cdot}</annotation></semantics></math></span></eq>理解成一种向量的标志，就像高中时用<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{a}</annotation></semantics></math></span></eq>来表示一个「名字叫做a的」向量一样。<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\ket{0}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>分别是名字叫做&quot;0&quot;的向量和名字叫做&quot;1&quot;的向量。</p>
<a id="more"></a>
<p>有了这个背景知识之后再去理解「叠加」就比较容易了。比如说一个Qubit <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>Q</mi><mo stretchy="false">⟩</mo><mo>=</mo><mn>0.6</mn><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>+</mo><mn>0.8</mn><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\ket{Q}=0.6\mathinner{|0\rangle}+0.8\mathinner{|1\rangle}</annotation></semantics></math></span></eq>,那么它就是这样子的一个向量：</p>
<p>【放一张图在这里】</p>
<p>好，到现在，最重要但是又反直觉的「叠加」就解释完了，接下来我们再来补充一些设定，按重要程度排序，越往后的越不用仔细理解（指一时半会也不能科普地讲清楚），看个热闹就行。</p>
<ul>
<li>一个量子比特的模长必须是1。也就是说，<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>前面的系数的「平方和」得是1。</li>
<li>而系数的平方其实就是当我「观测」这个量子比特时候，会坍缩到<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>或者<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>的概率，也就是说前面提到的那个Qubit<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>Q</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|Q\rangle}</annotation></semantics></math></span></eq>，在观测后会有36%的概率坍缩到<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>，有64%的概率坍缩到<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq></li>
<li>实际上前面的系数并不局限于实数，而可以是复数的……所以你注意到我把上面的「平方和」打了引号。</li>
<li>再实际上这作为系数的这几个复数具体是什么值其实不重要，重要的是它们之间的相对相位差。也就是说<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>+</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">a\mathinner{|0\rangle}+b\mathinner{|1\rangle}</annotation></semantics></math></span></eq>和 <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>+</mo><mi>b</mi><mi>i</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">ai\mathinner{|0\rangle}+bi\mathinner{|1\rangle}</annotation></semantics></math></span></eq>其实是同一个量子态。</li>
<li>因为量子态可以看做是向量，那么从一个量子态变换到另一个量子态的操作就可以看作是矩阵。为了维护变换前后的模长都是1，这些矩阵必须是幺正矩阵(Unitary Matrix)。</li>
<li>两个量子态可以写到一起，比如说<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>可以写作<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>10</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|10\rangle}</annotation></semantics></math></span></eq>，也就是之前两个向量的张量积。</li>
</ul>
<h2 id="计算与量子计算"><a class="markdownIt-Anchor" href="#计算与量子计算"></a> 计算与量子计算</h2>
<p>经典计算是怎么做到的呢？用一句话来概括，就是搞一个机器，根据输入的不同状态(bits)，把自己变成，或者说输出按照预设的规则相对应的状态(bits)。</p>
<p>打个比方，比如说有一个机器，输入5和8，输出13；输入13和21，输出34，那我们就知道这是一个加法器了。加法器其实是一系列「门电路」的组合，而门电路就是最简单的，输入一个或两个bits，输出一个bit的机器。</p>
<p>同样的，量子计算也有自己的「门电路」，比如说量子AND门，就是可以输入<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>,然后输出一个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>的机器……且慢，这里有些地方不太对，不过暂时可以这么理解着。</p>
<p>第一个不太对的地方是，我们上一节里提到过，对量子态的操作必须由要由幺正矩阵来进行，而熟悉线性代数的读者都知道，幺正变换是可逆的。AND门显然不可逆，光知道答案是<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>是判断不出输入的到底是<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>01</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|01\rangle}</annotation></semantics></math></span></eq>还是<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>10</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|10\rangle}</annotation></semantics></math></span></eq>还是<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>00</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|00\rangle}</annotation></semantics></math></span></eq>的。所以光靠幺正变换没办法得到一个单纯的AND门</p>
<p>第二个不太对的地方是……如果输入的不是纯的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>或者<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>，而是它们的某种叠加怎么办？</p>
<p>对于第一个问题，我们的解决办法是：再最后再补一位Qubit，变成3个Qubit的输入，3个Qubit的输出。也就是说，如果要算1 AND 0，我们不仅要输入一个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>和一个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>，还要补上一位，比如说这里补一个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>，让整个输入变成<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>100</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|100\rangle}</annotation></semantics></math></span></eq>。而在输出的地方，前两位保持输入不变，在第三位输出计算结果与补入的那一位的异或值(XOR)。也就是说，输入<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>100</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|100\rangle}</annotation></semantics></math></span></eq>，输出就变成<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>101</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|101\rangle}</annotation></semantics></math></span></eq>。为什么？因为1 AND 0 = 0，而0 XOR 0 = 1，所以最后一位变成了1。</p>
<p>而对于第二个问题，不妨把一个量子门当成一个变换矩阵<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathinner{A}</annotation></semantics></math></span></eq>，那么<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">∣</mi><mn>100</mn><mo stretchy="false">⟩</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mn>101</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">A\mathinner{|100\rangle}=\mathinner{|101\rangle}</annotation></semantics></math></span></eq>，而<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">∣</mi><mn>111</mn><mo stretchy="false">⟩</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mn>110</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">A\mathinner{|111\rangle}=\mathinner{|110\rangle}</annotation></semantics></math></span></eq>（因为1 AND 1 = 1，而 1 XOR 1 = 0）。好，如果现在的输入是某个叠加态，比如说 <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi mathvariant="normal">∣</mi><mn>100</mn><mo stretchy="false">⟩</mo><mo>+</mo><mi>β</mi><mi mathvariant="normal">∣</mi><mn>110</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\alpha\mathinner{|100\rangle}+\beta\mathinner{|110\rangle}</annotation></semantics></math></span></eq>，那么结果会是什么呢？</p>
<p>既然叠加和矩阵运算都是线性的，结果当然也是线性的，所以<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>α</mi><mi mathvariant="normal">∣</mi><mn>100</mn><mo stretchy="false">⟩</mo><mo>+</mo><mi>β</mi><mi mathvariant="normal">∣</mi><mn>110</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi><mi mathvariant="normal">∣</mi><mn>101</mn><mo stretchy="false">⟩</mo><mo>+</mo><mi>β</mi><mi mathvariant="normal">∣</mi><mn>110</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">A(\alpha\mathinner{|100\rangle}+\beta\mathinner{|110\rangle})=\alpha\mathinner{|101\rangle}+\beta\mathinner{|110\rangle}</annotation></semantics></math></span></eq>，发现了吗，这个机器同时进行了两个运算！</p>
<h2 id="有了这些之后量子计算机能干啥"><a class="markdownIt-Anchor" href="#有了这些之后量子计算机能干啥"></a> 有了这些之后量子计算机能干啥</h2>
<p>一个量子门能同时进行两个计算当然也能同时进行更多个，对于一个量子AND门来讲，他能同时把四种所有可能性（11、10、01、00）都算出来，但是这有什么用呢，输出的结果里面，四个答案都混在一起，分不出谁是谁啊？</p>
<p>那么，量子计算到底在哪个方面比经典计算机有优势呢？</p>
<p><strong>以下大量数学预警</strong>，趁现在去泡杯茶，然后开窗通风，深呼吸三次，再回来坐稳扶好——</p>
<p>考虑一个一般的问题，比如，判断<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\times b</annotation></semantics></math></span></eq>是否等于<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1643</mn></mrow><annotation encoding="application/x-tex">1643</annotation></semantics></math></span></eq>(你猜我为什么选择这个数），这是一个经典计算机非常好解决的问题，稍有编程基础的同学都可以在非常低的时间复杂度内给出答案。</p>
<p>那么，在这个问题中，一台经典计算机表现得像什么东西呢？比方说，我们用32个bits的二进制数来表示<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></eq>，（32-bit二进制数表示整数是计算机中非常常见的一种表达），再用32个bits来表示<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span></eq>，那么此时整台经典计算机就表现得像一个输入64个bits的函数 <eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mn>65</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(b_1,b_2,b_3 \dots ,b_{65})</annotation></semantics></math></span></eq> ，而这个函数的输出是一个bit，0代表不等于，1代表等于。</p>
<p>在经典计算机中，这样的函数是可以用一系列门电路的组合来实现的，而每一个经典门电路都有相对应的量子门电路，也就是说我们可以实现一个量子门电路组成的量子变换<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>,使得：</p>
<section><eqn><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mn>64</mn></msub><msub><mi>b</mi><mn>65</mn></msub><mo stretchy="false">⟩</mo><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mn>64</mn></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>b</mi><mn>64</mn></msub><mo stretchy="false">)</mo><mtext> xor </mtext><msub><mi>b</mi><mn>65</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">U_f\mathinner{|b_1b_2b_3...b_{64}b_{65}\rangle}=\mathinner{|b_1b_2b_3...b_{64}(f(b_1,b_2...b_{64}) \text{ xor } b_{65})\rangle}</annotation></semantics></math></span></eqn></section><p>总之就是，在输入的64位后面补一个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>65</mn></msub></mrow><annotation encoding="application/x-tex">b_{65}</annotation></semantics></math></span></eq>，在输出的地方保持前64位不变，最后一位变成f函数的输出值与<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>65</mn></msub></mrow><annotation encoding="application/x-tex">b_{65}</annotation></semantics></math></span></eq>的异或。</p>
<p>到这一步，我们终于证明了，用经典计算机可以算出来的问题，用量子计算机可以——至少在复杂度上可以——和经典计算机算得一样快……不给力啊老湿。</p>
<p>但是，我们有一个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>了，让我们看得再仔细一些，看看<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>到底能做些什么，比如说，我们假设前64位全部都缩写成<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|x\rangle}</annotation></semantics></math></span></eq>，然后最后一位输入<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{\sqrt{2}}(\mathinner{|0\rangle}-\mathinner{|1\rangle})</annotation></semantics></math></span></eq>，会怎么样？</p>
<p>//方便起见接下来的推导当中我就不写可以提取出来的公系数了（也就是那个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\sqrt{2}}</annotation></semantics></math></span></eq>），同学们读的时候记住每个量子态都把几个分量同时除以某个数让它的模长等于1就行</p>
<p>//但是我相信你们肯定会直接跳过的，哼</p>
<p>假设<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|x\rangle}</annotation></semantics></math></span></eq>是个没有叠加的纯态，那么<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span></eq>唯一确定。</p>
<section><eqn><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>U</mi><mi>f</mi></msub><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo>⊗</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>U</mi><mi>f</mi></msub><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">⟩</mo><mo>−</mo><msub><mi>U</mi><mi>f</mi></msub><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">⟩</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mi mathvariant="normal">¬</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo>⊗</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">¬</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
U_f[\mathinner{|x\rangle}\otimes (\mathinner{|0\rangle}-\mathinner{|1\rangle})]&amp;=U_f\mathinner{|x,0\rangle}-U_f\mathinner{|x,1\rangle}\\
&amp;= \mathinner{|x,f(x)\rangle}-\mathinner{|x,\neg f(x)\rangle}\\
&amp;=  \mathinner{|x\rangle} \otimes  (\mathinner{|f(x)\rangle}- \mathinner{|\neg f(x)\rangle})\\
\end{aligned}
</annotation></semantics></math></span></eqn></section><p>那么，分情况讨论，如果<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x)=0</annotation></semantics></math></span></eq>，则应用<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>进行变换之后的结果等于：</p>
<section><eqn><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo>⊗</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathinner{|x\rangle} \otimes  (\mathinner{|0\rangle}- \mathinner{|1\rangle})</annotation></semantics></math></span></eqn></section><p>恰好跟输入一毛一样，而如果<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=1</annotation></semantics></math></span></eq>,那么最后的结果就会等于：</p>
<section><eqn><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo>⊗</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathinner{|x\rangle} \otimes  (\mathinner{|1\rangle}- \mathinner{|0\rangle})</annotation></semantics></math></span></eqn></section><p>但是我们又知道，对于一个量子态，它的系数是什么不重要，系数的相对相位差才重要，也就是说我们可以在<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|x\rangle}</annotation></semantics></math></span></eq>的每一个分量和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathinner{|1\rangle}- \mathinner{|0\rangle})</annotation></semantics></math></span></eq>前面都乘以一个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span></eq>，得到</p>
<section><eqn><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo>⊗</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (-\mathinner{|x\rangle}) \otimes  (\mathinner{|0\rangle}- \mathinner{|1\rangle})</annotation></semantics></math></span></eqn></section><p>至于叠加态嘛，因为纯态之间都是互相垂直的，所以可以简单的正交分解成不同的纯态分别计算然后再加回来。</p>
<p><strong>//好了刚才跳过的同学们，这里是你们的空降点</strong></p>
<p>也就是说，我们发现在最后一位输入<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo><mo>−</mo><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{\sqrt{2}}(\mathinner{|0\rangle}-\mathinner{|1\rangle})</annotation></semantics></math></span></eq>之后，经过<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>的神奇操作，这个作为补位的最后一个Qubit保持不变，但是前面的那个<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|x\rangle}</annotation></semantics></math></span></eq>，会在<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=1</annotation></semantics></math></span></eq>的时候，神奇的变成<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">-\mathinner{|x\rangle}</annotation></semantics></math></span></eq>。那我要是把所有的纯态的可能，也就是从64个0到64个1这<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span></eq>种纯态，全部都均匀地叠加在一起输入<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>机器，会怎样？</p>
<p>接下来的事情需要一些空间想象力，考虑到所有的可能性都叠加在一起之后的量子态依然是一个向量，我们就叫他<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\psi\rangle}</annotation></semantics></math></span></eq>吧，它不沿着任意一个坐标轴，而是均匀地与任意一个坐标轴保持着距离。</p>
<p>我们再考虑，所有能让<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=1</annotation></semantics></math></span></eq>的可能的纯态叠加在一起，应该也是一个向量，而且会在这个空间中指出一个确定的方向。我们就叫它<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>好了。</p>
<p>现在，<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\psi\rangle}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>两个向量在空间中张开了一个角度，它们确定了一个平面。在这个平面上，我们找到与<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>垂直的那个方向，叫它<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\bar{a}\rangle}</annotation></semantics></math></span></eq>，然后把<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\psi\rangle}</annotation></semantics></math></span></eq>沿着这两个方向正交分解……</p>
<p>我们现在拥有<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\psi\rangle}</annotation></semantics></math></span></eq>的两个分量了，沿<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>方向的分量在应用一次<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>后会被反向，而沿<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\bar{a}\rangle}</annotation></semantics></math></span></eq>方向的分量则保持不变。这意味着，<strong>每次进行<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>操作后，我们的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\psi\rangle}</annotation></semantics></math></span></eq>都会对称于<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\bar{a}\rangle}</annotation></semantics></math></span></eq>方向翻转。</strong></p>
<p>有了这个结论之后，我们已经有量子搜索的全貌的一半了。接下来我们要<strong>构造另一个矩阵<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span></eq>，它所对应的变化是，让一个向量对称于「所有纯态的叠加」<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\Psi\rangle}</annotation></semantics></math></span></eq>翻转</strong>。</p>
<p>注意这次的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ψ</mi></mrow><annotation encoding="application/x-tex">\Psi</annotation></semantics></math></span></eq>是大写的，因为这次不是那个翻来翻去的向量，而是对称轴本身了。</p>
<p>这个矩阵如何构造，留给读者证明（逃）</p>
<p>//哎呀反正你只要知道这个矩阵是构造得出来的不就行了嘛！</p>
<p>最后一点点微小的工作是，在维度（指Qubit的数量）足够高，且能让<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=1</annotation></semantics></math></span></eq>的x足够少的时候，<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\Psi\rangle}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>是几乎垂直的，这使得<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\Psi\rangle}</annotation></semantics></math></span></eq>和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\bar{a}\rangle}</annotation></semantics></math></span></eq>之间的夹角非常小，大约与<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msqrt><mi>N</mi></msqrt></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\sqrt{N}}</annotation></semantics></math></span></eq>成正比。</p>
<p>好，接下来我们从<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\Psi\rangle}</annotation></semantics></math></span></eq>开始，先用<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>翻转一次，再用<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span></eq>翻转一次，再用<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">U_f</annotation></semantics></math></span></eq>翻转一次，再用<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span></eq>翻转一次……注意每次组翻转都会让我们的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\psi\rangle}</annotation></semantics></math></span></eq>距离<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\bar{a}\rangle}</annotation></semantics></math></span></eq>都增加<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>θ</mi></mrow><annotation encoding="application/x-tex">2\theta</annotation></semantics></math></span></eq>，在大约<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>4</mn></mfrac><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\frac{\pi}{4}\sqrt{N}</annotation></semantics></math></span></eq>次翻转之后，我们的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ψ</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|\psi\rangle}</annotation></semantics></math></span></eq>向量已经离<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>非常接近了。这个时候再对这个量子态进行观测，它就会有极高的概率坍缩到<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>上（如果<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>是个纯态），或者由更高的概率坍缩到组成<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>的某一个纯态上去（如果<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|a\rangle}</annotation></semantics></math></span></eq>是由少数几个可能的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|x\rangle}</annotation></semantics></math></span></eq>叠加而来），终于的终于，我们用了<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>N</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{N})</annotation></semantics></math></span></eq>的时间复杂度，找到了一个能让<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=1</annotation></semantics></math></span></eq>的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></eq>。</p>
<p><strong>经典计算机做得到吗！</strong></p>
<p>我们终于可以回去讲为什么是1643了，因为它是两个质数：31和53的乘积。也就是说这个问题其实是一个分解质因数的问题——这其实算便宜经典计算机了，毕竟分解质因数是有不用遍历所有可能性的搜索方法的，如果换一个别的搜索题，经典计算机可能就需要在整个可能性范围内用<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span></eq>的复杂度搜过来。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2>
<ol>
<li>叠加态并不是数轴上1和0中间的某一个点，是互相垂直的<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>向量和<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>向量的线性组合，且长度必须为1。</li>
<li>对量子比特进行观测它就会坍缩到<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>1</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|1\rangle}</annotation></semantics></math></span></eq>或者<eq><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mn>0</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\mathinner{|0\rangle}</annotation></semantics></math></span></eq>中的某一个，这个向量离谁更近坍缩到谁的概率就更大。</li>
<li>对量子比特进行操作需要保证操作的幺正性，这也是后面所有幺蛾子的基础</li>
<li>量子计算机确实能同时计算一大批输入，只要把输入叠加起来就行了，并没有什么卵用因为输出也都是叠加在一起的。</li>
<li>量子算法的真正牛逼之处是可以逐渐地让一个量子态坍缩到有效的答案的概率不断增加。而且增加得很快。</li>
<li>还有其他牛逼的量子算法就不展开讲了。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/" rel="tag"># 量子信息</a>
              <a href="/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/" rel="tag"># 量子计算</a>
              <a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="tag"># 线性代数</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/p/53044.html" rel="next" title="卟">
                  <i class="fa fa-chevron-left"></i> 卟
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/p/49632.html" rel="prev" title="Leela Zero 赶上AlphaGo Zero 了吗？">
                  Leela Zero 赶上AlphaGo Zero 了吗？ <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#比特与量子比特"><span class="nav-number">1.</span> <span class="nav-text"> 比特与量子比特</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算与量子计算"><span class="nav-number">2.</span> <span class="nav-text"> 计算与量子计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有了这些之后量子计算机能干啥"><span class="nav-number">3.</span> <span class="nav-text"> 有了这些之后量子计算机能干啥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text"> 总结：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Anchor"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Anchor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Anchor</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'reNDV4BpVHOaP6TyKdWqr7Q0-MdYXbMMI',
    appKey: 'PDrmNwAzUOWTiGI1sKOKEv08',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
